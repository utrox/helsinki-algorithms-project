# Implementation documentation

## General structure of the program
- Key generation: 
    - Generate two random integers of a certain bitsize, then decide if they are prime or not.
    - We check primality using the Miller-Rabin algorithm and Sieve of Eratosthenes. 
    - Calculate n, phi n, and the private exponent 
    - Return the public key (public exponent, n) and the private key (private exponent, n).
- Encoding and decoding using the key:
    - Convert the message to bits, then integers.
    - Encode the message int using the public/private  exponent to get the ciphertext.
    - Decode a ciphertext using the private/public key, convert to bytes, then back to a message.
        - 1.) CONFIDENTIALITY (Encryption with the reciever's public key, decryption with their private key.)
        - 2.) AUTHENTICITY (Encryption with the sender's private key, decryption with the sender's public key.)
        - 3.) BOTH (Encryption first with the sender's private key, then the reciever's public key. Decryption using first the reciever's private key, then the sender's public key.)
- Keygen:
    - Originally not part of the initial scope of the project, but I was curious how it's done.
    - After generating the keys, have the ability to store them in .der files.
    - You also have the ability to read the keys from the files.
- An interface with which the user can test the functionality (terminal application)

## Achieved time complexity
- is_prime() time complexity: 
    - Checking if the generated number is divisible by any of the numbers previously generated by sieve_of_eratosthenes: O(1), because the list is always the same length.
    - Factorization: O(log n)
    - Miller-Rabin test: O(k * log n)
    - In total: O(k * log^2 n)
- Encryption and decryption uses modular exponentiation because of the large numbers. 


## Possible improvements
- Refactoring into class-based design - right now passing a lot of variables to different functions is cumbersome.
- Because of this, the code would not be the best choice to use by others for example as a package. 


## Use of extensive language models:
During the development of the project, ChatGPT was used to explain and discuss mathematical and algorithmic concepts.

No code was generated by artifficial intelligence. 
